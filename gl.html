<!DOCTYPE html>
<head>
    <meta charset="utf-8">
    <style>
        body { font: 12px sans-serif; }
        #circle circle { fill: none; pointer-events: all; }
        .group path { fill-opacity: .5; }
        path.chord, .title { stroke: #222; stroke-width: .25px; }
        #circle:hover path.fade { display: none; }
    </style>
</head>
<body>
<h1></h1>
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/queue.v1.min.js"></script>
<script>
    var width = 720,
        height = 720,
        outerRadius = Math.min(width, height) / 2 - 10,
        innerRadius = outerRadius - 24;

    var formatPercent = d3.format(".1%");
    var color = d3.scale.category10();

    var arc = d3.svg.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);

    var layout = d3.layout.chord()
        .padding(.05)
        .sortSubgroups(d3.descending)
        .sortChords(d3.ascending);

    var path = d3.svg.chord().radius(innerRadius);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("id", "circle")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    svg.append("circle").attr("r", outerRadius);

    /*
    select distinct pu_area from jobs

    select distinct p.pu_area, p.do_area,
    	(select count(d.do_area) from jobs d where d.do_area = p.do_area) count
    from jobs p where p.do_area is not null order by p.pu_area, p.do_area
    */

    queue()
        .defer(d3.csv, "data/area.csv")
        .defer(d3.csv, "data/pu_area_do_area.csv", function (d) {
            return {key: d.pu_area + ':' + d.do_area, value: +d.count};
        })
        .await(ready);

    function ready(error, area, pu_area_do_area) {
        if (error) throw error;

        var sum = d3.sum(pu_area_do_area, function (d) { return d.value; });
        document.querySelector('h1').innerHTML = 'GroundLink Rides [' + sum + '] by Neighborhood';

        var tmp = d3.map(pu_area_do_area, function (d) { return d.key; });
        var matrix = [];
        for (var j = 0; j < area.length; j++) {
            matrix[j] = [];
            for (var k = 0; k < area.length; k++) {
                var found = tmp.get(area[j].area + ':' + area[k].area);
                if (found === undefined) {
                    matrix[j][k] = 0;
                } else {
                    matrix[j][k] = found.value / sum;
                }
            }
        }
        // Compute the chord layout.
        layout.matrix(matrix);

        // Add a group per neighborhood.
        var group = svg.selectAll(".group")
            .data(layout.groups)
            .enter().append("g")
            .attr("class", "group")
            .on("mouseover", mouseover);

        // Add a mouseover title.
        group.append("title").text(function (d, i) {
            return area[i].name + ": " + formatPercent(d.value) + " of origins";
        });

        // Add the group arc.
        var groupPath = group.append("path")
            .attr("id", function (d, i) {
                return "group" + i;
            })
            .attr("class", "title")
            .attr("d", arc)
            .style("fill", function (d, i) { return color(i); });

        // Add a text label.
        var groupText = group.append("text").attr("x", 6).attr("dy", 15);

        groupText.append("textPath")
            .attr("xlink:href", function (d, i) {
                return "#group" + i;
            })
            .text(function (d, i) {
                return area[i].name;
            });

        // Remove the labels that don't fit. :(
        groupText.filter(function (d, i) {
            return groupPath[0][i].getTotalLength() / 2 - 16 < this.getComputedTextLength();
        }).remove();

        // Add the chords.
        var chord = svg.selectAll(".chord")
            .data(layout.chords)
            .enter().append("path")
            .attr("class", "chord")
            .style("fill", function (d) {
                return color(d.source.index);
            })
            .attr("d", path);

        // Add an elaborate mouseover title for each chord.
        chord.append("title").text(function (d) {
            return area[d.source.index].name
                + " → " + area[d.target.index].name
                + ": " + formatPercent(d.source.value)
                + "\n" + area[d.target.index].name
                + " → " + area[d.source.index].name
                + ": " + formatPercent(d.target.value);
        });

        function mouseover(d, i) {
            chord.classed("fade", function (p) {
                return p.source.index != i && p.target.index != i;
            });
        }
    }
</script>
</body>
